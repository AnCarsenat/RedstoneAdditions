import os

class Mcfunction:
    def __init__(self, file_location):
        self.file_location = file_location

        if not os.path.exists(file_location):
            os.makedirs(os.path.dirname(file_location), exist_ok=True)
            self.file = open(file_location, "w", encoding="utf-8")
        else:
            self.file = open(file_location, "w", encoding="utf-8")

        self._write_header()

    def _write_header(self):
        header_lines = [
            "# Minecraft function file",
            "# This file was created by Reddition",
            "# Do not edit this file manually",
            "",
        ]
        for line in header_lines:
            self.write_line(line)

    def clear_file(self):
        self.file.seek(0)
        self.file.truncate()

    def close(self):
        self.file.close()

    def write_line(self, text):
        self.file.write(text + "\n")

    def write_lines(self, lines):
        for line in lines:
            self.write_line(line)

    def write(self, text):
        self.file.write(text)

    def __str__(self):
        return f"{self.__class__.__name__}(file_location='{self.file_location}')"  


class BlockPlace:

    class blockTickMcfunction:
        def __init__(self, name, commands=[str]):
            self.name = name
            self.commands = commands

        def write_line(self, text):
            self.mcfunction.write_line(text)

        def close(self):
            self.mcfunction.close()

        def __str__(self):
            return f"{self.__class__.__name__}(name='{self.name}', commands={self.commands})"

    class FacingTypes:
        # New static members for direct access
        ALL = {0: "down", 1: "up", 2: "north", 3: "south", 4: "west", 5: "east"}
        HORIZONTAL = {1: "north"}
        WALL = {2: "north", 3: "south", 4: "west", 5: "east"}
        GATE = {2: "north", 3: "south", 4: "west", 5: "east"}
        LINK = {2: "east", 3: "west", 4: "north", 5: "south"}

    def __init__(
        self,
        block: str,
        facing_type: dict[int, str],
        block_tick: blockTickMcfunction = None,
    ):
        self.block_tick = block_tick
        self.block = block
        self.facing_type = facing_type

    def __str__(self):
        return f"{self.__class__.__name__}(block='{self.block}', facing_type={self.facing_type}, block_tick={self.block_tick})"


class Item:
    def __init__(
        self,
        name,
        item_id: str,
        item_model: str,
        item_name: str,
        additional_item_data: str,
        entity_data: str = None,
        entity_tags: list[str] = None,
        block_place: BlockPlace = None,
    ):
        self.name = name
        self.item_id = item_id
        self.item_model = item_model
        self.item_name = item_name
        self.entity_data = entity_data
        self.additional_item_data = additional_item_data
        self.entity_tags = entity_tags
        self.block_place = block_place

        # Initialize additional_item_data if None
        if self.additional_item_data is None:
            self.additional_item_data = ""

    def __str__(self):
        return f"{self.name}: {self.item_model}, {self.item_name}, {self.entity_data}"

    def generate_give_command(self):
        # Add custom data tag for inventory checking
        # Start building the components string
        components = []
        components.append(f'minecraft:item_model="{self.item_model}"')
        
        # Handle JSON text components correctly
        components.append(f'minecraft:item_name=\'{self.item_name}\'')
            
        # Only include custom_data if not in additional_item_data
        components.append(f'minecraft:custom_data={{"{self.name}":true}}')
            
        # Add additional item data if present
        if self.additional_item_data:
            # Remove the leading comma if present
            clean_additional = self.additional_item_data.lstrip(',')
            components.append(clean_additional)
            
        # Add entity data if present
        if self.entity_data and self.entity_tags:
            components.append(f'minecraft:entity_data={{id:"{self.entity_data["id"]}",Tags:{self.entity_tags}}}')

        # Join all components with commas
        components_str = ','.join(filter(None, components))

        # Create the final give command
        return f"give @s {self.item_id}[{components_str}]"

    def generate_child_entities_selector(self):
        return f"@e[type={self.item_id},nbt={{Tags:{self.entity_tags}}}]"

    def generate_child_entities_selector_from_id(self, id, long=False, additional_tags=None):
        if long:
            return f"@e[type={id},nbt={{Tags:{self.entity_tags}}}]"
        return f"@e[type={id},tag={self.entity_tags[0]}]"
    
    def generate_item_entity_selector(self):
        # Check for item entity with custom data and specific tag
        return f'@e[type=item,nbt={{Item:{{components:{{"minecraft:custom_data":{{{self.name}:true}}}}}}}}]'

    def generate_is_holding_item(self):
        return f"execute if entity @s[nbt={{SelectedItem:{{components:{{'minecraft:custom_data':{{ {self.name}:true}}}}}}}}] run"

    def get_block_facing_values(self):
        if self.block_place:
            return self.block_place.facing_values
        return {}
    
    def get_recipe_result_format(self):
        result = {
            "id": self.item_id,
            "components": {
            "minecraft:item_name": self.item_name,
            "minecraft:item_model": self.item_model,
            "minecraft:custom_data": {
                str(self.name): True
            }
            }
        }
        
        if self.entity_data and self.entity_tags:
            result["components"]["minecraft:entity_data"] = {
                "id": self.entity_data["id"],
                "Tags": self.entity_tags
            }

        result = str(result)
        

        result = result.replace("True", "true")

        result = result.replace('"', "\\\"")
        result = result.replace("'", '"')

        return result
    
    def generate_item_summon_command(self):
        """
        Generates a summon command for an item based on its parameters.
        This function is adaptable and replicable for other items.

        Returns:
            str: The summon command string.
        """
        # Start building the components string
        components = []
        components.append(f'"minecraft:item_model":"{self.item_model}"')
        components.append(f'"minecraft:item_name":\'{self.item_name}\'')
        components.append(f'"minecraft:custom_data":{{"{self.name}":true}}')

        # Handle additional item data if present
        if self.additional_item_data:
            # Split and process each additional data item
            for item in self.additional_item_data.split(','):
                if '=' in item:
                    key, value = item.split('=')
                    # Format value without quotes for booleans and numbers
                    if value.lower() in ['true', 'false'] or value.isdigit():
                        formatted_value = value.lower()
                    else:
                        formatted_value = f'"{value}"'
                    components.append(f'"{key}":{formatted_value}')

        # Add entity data if present
        if self.entity_data and self.entity_tags:
            components.append(f'"minecraft:entity_data":{{id:"{self.entity_data["id"]}",Tags:{self.entity_tags}}}')

        # Join components into a single string
        components_str = ','.join(filter(None, components))

        return f"summon item ~ ~ ~ {{Item:{{id:\"{self.item_id}\",Count:1b,components:{{{components_str}}}}}}}"
    
    def get_block(self):
        if self.block_place:
            return self.block_place.block
        return None
    



# Constants for paths
REDDITION_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
DATA_DIR = os.path.join(REDDITION_ROOT, "Build", "datapack")
BUILD_PATH = os.path.join(REDDITION_ROOT, "Build")
BUILD_DATAPACK_PATH = os.path.join(BUILD_PATH, "datapack")

print(f"REDDITION_ROOT: {REDDITION_ROOT}")
print(f"DATA_DIR: {DATA_DIR}")
print(f"BUILD_PATH: {BUILD_PATH}")
print(f"BUILD_DATAPACK_PATH: {BUILD_DATAPACK_PATH}")


def setup_working_directory():
    working_directory = os.path.join(DATA_DIR)
    os.makedirs(working_directory, exist_ok=True)
    return working_directory


def make_necessary_folder(file_path):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
